{"version":3,"sources":["methods/methodMapping.ts","transports/MetaMaskTransport.ts","index.tsx"],"names":["transport","MetaMaskTransport","notificationHandler","message","m","window","parent","postMessage","method","type","params","data","hasEthereum","ethereum","isMetaMask","on","this","Boolean","Error","request","results","off","Transport","internalID","methodMapping","connect","a","sendData","addEventListener","ev","jsonrpc","eventSource","source","result","openrpcDocument","id","origin","error","code","then","catch","e","serializeError","shouldIncludeStack"],"mappings":"oSAOIA,ECkDWC,E,4nBATLC,oBAAsB,SAACC,GAC7B,IAAMC,EAASD,EACfE,OAAOC,OAAOC,YAAY,CACxBC,OAAQJ,EAAEK,KACVC,OAAQN,EAAEO,MACT,M,oFA1BL,2FACQC,EAAcP,OAAOQ,UAAYR,OAAOQ,SAASC,YADzD,uBAGI,UAAAT,OAAOQ,gBAAP,SAAiBE,GAAG,UAAWC,KAAKd,qBAHxC,kBAIWe,QAAQL,IAJnB,aAMU,IAAIM,MAAM,0BANpB,gD,mHAUA,WAAsBP,GAAtB,2HAA8E,IAA9E,mBACwBN,OAAOQ,gBAD/B,aACwB,EAAiBM,QAASR,EAAsBQ,SADxE,cACQC,EADR,yBAESA,GAFT,2C,0EAKA,WACMf,OAAOQ,UACTR,OAAOQ,SAASQ,IAAI,UAAWL,KAAKd,yB,SAnBVoB,WDjB5BC,EAAa,EAsBFC,EALuB,CACpCC,QAhBoB,uCAAG,sBAAAC,EAAA,6DACvB1B,EAAY,IAAIC,EADO,kBAEhBD,EAAUyB,WAFM,2CAAH,qDAiBpBE,SAZyB,SAAChB,GAC1B,IAAKX,EACH,MAAM,IAAIkB,MAAM,iBAElB,OAAOlB,EAAU2B,SAAS,CACxBJ,WAAYA,IACZJ,QAASR,M,QEjBbN,OAAOuB,iBAAiB,UAAxB,uCAAmC,WAAOC,GAAP,eAAAH,EAAA,yDAC5BG,EAAGlB,KAAKmB,QADoB,oDAK3BC,EAAsBF,EAAGG,OAER,iBAAnBH,EAAGlB,KAAKH,OAPqB,uBAQ/BuB,EAAYxB,YAAY,CACtBuB,QAAS,MACTG,OAAQC,EACRC,GAAIN,EAAGlB,KAAKwB,IACXN,EAAGO,QAZyB,6BAe5BZ,EAAcK,EAAGlB,KAAKH,QAfM,uBAgB/BuB,EAAYxB,YAAY,CACtBuB,QAAS,MACTO,MAAO,CACLC,KAAM,MACNnC,QAAS,oBAEXgC,GAAIN,EAAGlB,KAAKwB,IACXN,EAAGO,QAvByB,0BA0BjCZ,EAAcK,EAAGlB,KAAKH,QAAtB,MAAAgB,EAAa,YAAoBK,EAAGlB,KAAKD,QAA5B,QAAoCmB,EAAGO,UAAQG,MAAK,SAACnB,GAChEW,EAAYxB,YAAY,CACtBuB,QAAS,MACTG,OAAQb,EACRe,GAAIN,EAAGlB,KAAKwB,IACXN,EAAGO,WACLI,OAAM,SAACC,GACRV,EAAYxB,YAAY,CACtBuB,QAAS,MACTO,MAAOK,yBAAeD,EAAG,CAAEE,oBAAoB,IAC/CR,GAAIN,EAAGlB,KAAKwB,IACXN,EAAGO,WArCyB,4CAAnC,uDAyCe,c","file":"static/js/main.ea47caac.chunk.js","sourcesContent":["import { Connect, SendData } from \"../__GENERATED_TYPES__\";\nimport MetaMaskTransport from \"../transports/MetaMaskTransport\";\n\nexport interface IMethodMapping {\n  [methodName: string]: (...params: any) => Promise<any>;\n}\n\nlet transport: MetaMaskTransport | undefined;\nlet internalID = 0;\n\nconst connect: Connect = async () => {\n  transport = new MetaMaskTransport();\n  return transport.connect();\n};\n\nconst sendData: SendData = (data) => {\n  if (!transport) {\n    throw new Error(\"Not Connected\");\n  }\n  return transport.sendData({\n    internalID: internalID++,\n    request: data,\n  });\n};\n\nconst methodMapping: IMethodMapping = {\n  connect,\n  sendData,\n};\n\nexport default methodMapping;\n","import { Transport } from \"@open-rpc/client-js/build/transports/Transport\";\nimport { EventEmitter } from \"events\";\nimport { JSONRPCRequestData, IJSONRPCData } from \"@open-rpc/client-js/build/Request\";\n\ninterface RequestArguments {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object;\n}\n\ninterface EthereumProvider extends EventEmitter {\n  isMetaMask?: boolean;\n  request: (args: RequestArguments) => Promise<unknown>;\n}\n\ndeclare global {\n  interface Window {\n    ethereum?: EthereumProvider;\n  }\n}\n\ninterface ProviderMessage {\n  readonly type: string;\n  readonly data: unknown;\n}\n\nclass MetaMaskTransport extends Transport {\n\n  public async connect(): Promise<boolean> {\n    const hasEthereum = window.ethereum && window.ethereum.isMetaMask;\n    if (hasEthereum) {\n      window.ethereum?.on(\"message\", this.notificationHandler);\n      return Boolean(hasEthereum);\n    } else {\n      throw new Error(\"No MetaMask Connection\");\n    }\n  }\n\n  public async sendData(data: JSONRPCRequestData, timeout: number | undefined = 5000): Promise<any> {\n    const results = await window.ethereum?.request((data as IJSONRPCData).request);\n    return results;\n  }\n\n  public close(): void {\n    if (window.ethereum) {\n      window.ethereum.off(\"message\", this.notificationHandler);\n    }\n  }\n\n  private notificationHandler = (message: ProviderMessage) => {\n    const m: any = message;\n    window.parent.postMessage({\n      method: m.type,\n      params: m.data,\n    }, \"*\");\n  }\n}\n\nexport default MetaMaskTransport;\n","import openrpcDocument from \"./openrpc.json\";\nimport methodMapping from \"./methods/methodMapping\";\nimport {EthereumRpcError, serializeError} from \"eth-rpc-errors\";\n\nwindow.addEventListener(\"message\", async (ev: MessageEvent) => {\n  if (!ev.data.jsonrpc) {\n    return;\n  }\n\n  const eventSource: Window = ev.source as Window;\n\n  if (ev.data.method === \"rpc.discover\") {\n    eventSource.postMessage({\n      jsonrpc: \"2.0\",\n      result: openrpcDocument,\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  if (!methodMapping[ev.data.method]) {\n    eventSource.postMessage({\n      jsonrpc: \"2.0\",\n      error: {\n        code: 32009,\n        message: \"Method not found\",\n      },\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  methodMapping[ev.data.method](...ev.data.params, ev.origin).then((results: any) => {\n    eventSource.postMessage({\n      jsonrpc: \"2.0\",\n      result: results,\n      id: ev.data.id,\n    }, ev.origin);\n  }).catch((e: EthereumRpcError<any>) => {\n    eventSource.postMessage({\n      jsonrpc: \"2.0\",\n      error: serializeError(e, { shouldIncludeStack: true }),\n      id: ev.data.id,\n    }, ev.origin);\n  });\n});\n\nexport default {};\n"],"sourceRoot":""}