{"version":3,"sources":["methods/methodMapping.ts","transports/MetaMaskTransport.ts","index.tsx"],"names":["transport","MetaMaskTransport","uri","notificationHandler","message","m","window","parent","postMessage","method","type","params","data","hasEthereum","ethereum","on","this","request","results","off","Transport","internalID","methodMapping","connect","a","sendData","Error","addEventListener","ev","source","jsonrpc","result","openrpcDocument","id","origin","error","code","then","catch","e"],"mappings":"gSAOIA,ECqDWC,E,keAhCb,WAAYC,GAAc,IAAD,8BACvB,gBAHKA,SAEkB,IAuBjBC,oBAAsB,SAACC,GAC7B,IAAMC,EAASD,EACfE,OAAOC,OAAOC,YAAY,CACxBC,OAAQJ,EAAEK,KACVC,OAAQN,EAAEO,MACT,MA1BH,EAAKV,IAAMA,EAFY,E,kFAIzB,2FACQW,EAAeP,OAAeQ,WAElCD,EAAYE,GAAG,UAAWC,KAAKb,qBAHnC,oBAKWU,GALX,gD,mHAQA,WAAsBD,GAAtB,2HAA8E,IAA9E,mBACwBN,OAAOQ,gBAD/B,aACwB,EAAiBG,QAASL,EAAsBK,SADxE,cACQC,EADR,yBAESA,GAFT,2C,0EAKA,WACMZ,OAAOQ,UACTR,OAAOQ,SAASK,IAAI,UAAWH,KAAKb,yB,QAtBViB,WDjB5BC,EAAa,EAuBFC,EALuB,CACpCC,QAjBoB,uCAAG,WAAOrB,GAAP,SAAAsB,EAAA,6DACvBxB,EAAY,IAAIC,EAAkBC,GADX,SAEjBF,EAAUuB,UAFO,iCAGhB,GAHgB,2CAAH,sDAkBpBE,SAZyB,SAACb,GAC1B,IAAKZ,EACH,MAAM,IAAI0B,MAAM,iBAElB,OAAO1B,EAAUyB,SAAS,CACxBJ,WAAYA,IACZJ,QAASL,MEnBbN,OAAOqB,iBAAiB,UAAxB,uCAAmC,WAAOC,GAAP,SAAAJ,EAAA,yDACV,iBAAnBI,EAAGhB,KAAKH,OADqB,uBAE9BmB,EAAGC,OAAerB,YAAY,CAC7BsB,QAAS,MACTC,OAAQC,EACRC,GAAIL,EAAGhB,KAAKqB,IACXL,EAAGM,QANyB,6BAS5BZ,EAAcM,EAAGhB,KAAKH,QATM,uBAU/BH,OAAOC,OAAOC,YAAY,CACxBsB,QAAS,MACTK,MAAO,CACLC,KAAM,MACNhC,QAAS,oBAEX6B,GAAIL,EAAGhB,KAAKqB,IACXL,EAAGM,QAjByB,0BAoBjCZ,EAAcM,EAAGhB,KAAKH,QAAtB,MAAAa,EAAa,YAAoBM,EAAGhB,KAAKD,QAA5B,QAAoCiB,EAAGM,UAAQG,MAAK,SAACnB,GAChEZ,OAAOC,OAAOC,YAAY,CACxBsB,QAAS,MACTC,OAAQb,EACRe,GAAIL,EAAGhB,KAAKqB,IACXL,EAAGM,WACLI,OAAM,SAACC,GACPX,EAAGC,OAAerB,YAAY,CAC7BsB,QAAS,MACTK,MAAO,CACLC,KAAM,MACNhC,QAASmC,EAAEnC,SAEb6B,GAAIL,EAAGhB,KAAKqB,IACXL,EAAGM,WAlCyB,2CAAnC,uDAsCe,c","file":"static/js/main.f7606323.chunk.js","sourcesContent":["import { Connect, SendData } from \"../__GENERATED_TYPES__\";\nimport MetaMaskTransport from \"../transports/MetaMaskTransport\";\n\nexport interface IMethodMapping {\n  [methodName: string]: (...params: any) => Promise<any>;\n}\n\nlet transport: MetaMaskTransport | undefined;\nlet internalID = 0;\n\nconst connect: Connect = async (uri) => {\n  transport = new MetaMaskTransport(uri);\n  await transport.connect();\n  return true;\n};\n\nconst sendData: SendData = (data) => {\n  if (!transport) {\n    throw new Error(\"Not Connected\");\n  }\n  return transport.sendData({\n    internalID: internalID++,\n    request: data,\n  });\n};\n\nconst methodMapping: IMethodMapping = {\n  connect,\n  sendData,\n};\n\nexport default methodMapping;\n","import { Transport } from \"@open-rpc/client-js/build/transports/Transport\";\nimport { EventEmitter } from \"events\";\nimport { JSONRPCRequestData, IJSONRPCData } from \"@open-rpc/client-js/build/Request\";\n\ninterface RequestArguments {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object;\n}\n\ninterface EthereumProvider extends EventEmitter {\n  isMetaMask?: boolean;\n  request: (args: RequestArguments) => Promise<unknown>;\n}\n\ndeclare global {\n  interface Window {\n    ethereum?: EthereumProvider;\n  }\n}\n\ninterface ProviderMessage {\n  readonly type: string;\n  readonly data: unknown;\n}\n\nclass MetaMaskTransport extends Transport {\n  public uri: string;\n\n  constructor(uri: string) {\n    super();\n    this.uri = uri;\n  }\n  public async connect(): Promise<any> {\n    const hasEthereum = (window as any).ethereum;\n    if (hasEthereum) {\n      hasEthereum.on(\"message\", this.notificationHandler);\n    }\n    return !!hasEthereum;\n  }\n\n  public async sendData(data: JSONRPCRequestData, timeout: number | undefined = 5000): Promise<any> {\n    const results = await window.ethereum?.request((data as IJSONRPCData).request);\n    return results;\n  }\n\n  public close(): void {\n    if (window.ethereum) {\n      window.ethereum.off(\"message\", this.notificationHandler);\n    }\n  }\n\n  private notificationHandler = (message: ProviderMessage) => {\n    const m: any = message;\n    window.parent.postMessage({\n      method: m.type,\n      params: m.data,\n    }, \"*\");\n  }\n}\n\nexport default MetaMaskTransport;\n","import openrpcDocument from \"./openrpc.json\";\nimport methodMapping from \"./methods/methodMapping\";\n\nwindow.addEventListener(\"message\", async (ev: MessageEvent) => {\n  if (ev.data.method === \"rpc.discover\") {\n    (ev.source as any).postMessage({\n      jsonrpc: \"2.0\",\n      result: openrpcDocument,\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  if (!methodMapping[ev.data.method]) {\n    window.parent.postMessage({\n      jsonrpc: \"2.0\",\n      error: {\n        code: 32009,\n        message: \"Method not found\",\n      },\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  methodMapping[ev.data.method](...ev.data.params, ev.origin).then((results: any) => {\n    window.parent.postMessage({\n      jsonrpc: \"2.0\",\n      result: results,\n      id: ev.data.id,\n    }, ev.origin);\n  }).catch((e: Error) => {\n    (ev.source as any).postMessage({\n      jsonrpc: \"2.0\",\n      error: {\n        code: 32329,\n        message: e.message,\n      },\n      id: ev.data.id,\n    }, ev.origin);\n  });\n});\n\nexport default {};\n"],"sourceRoot":""}