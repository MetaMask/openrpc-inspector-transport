{"version":3,"sources":["methods/methodMapping.ts","transports/MetaMaskTransport.ts","index.tsx"],"names":["transport","MetaMaskTransport","notificationHandler","message","m","window","parent","postMessage","method","type","params","data","hasEthereum","ethereum","isMetaMask","on","this","Boolean","Error","request","results","off","Transport","internalID","methodMapping","connect","a","sendData","addEventListener","ev","source","jsonrpc","result","openrpcDocument","id","origin","error","code","then","catch","e"],"mappings":"gSAOIA,ECkDWC,E,4nBATLC,oBAAsB,SAACC,GAC7B,IAAMC,EAASD,EACfE,OAAOC,OAAOC,YAAY,CACxBC,OAAQJ,EAAEK,KACVC,OAAQN,EAAEO,MACT,M,oFA1BL,2FACQC,EAAcP,OAAOQ,UAAYR,OAAOQ,SAASC,YADzD,uBAGI,UAAAT,OAAOQ,gBAAP,SAAiBE,GAAG,UAAWC,KAAKd,qBAHxC,kBAIWe,QAAQL,IAJnB,aAMU,IAAIM,MAAM,0BANpB,gD,mHAUA,WAAsBP,GAAtB,2HAA8E,IAA9E,mBACwBN,OAAOQ,gBAD/B,aACwB,EAAiBM,QAASR,EAAsBQ,SADxE,cACQC,EADR,yBAESA,GAFT,2C,0EAKA,WACMf,OAAOQ,UACTR,OAAOQ,SAASQ,IAAI,UAAWL,KAAKd,yB,QAnBVoB,WDjB5BC,EAAa,EAsBFC,EALuB,CACpCC,QAhBoB,uCAAG,sBAAAC,EAAA,6DACvB1B,EAAY,IAAIC,EADO,kBAEhBD,EAAUyB,WAFM,2CAAH,qDAiBpBE,SAZyB,SAAChB,GAC1B,IAAKX,EACH,MAAM,IAAIkB,MAAM,iBAElB,OAAOlB,EAAU2B,SAAS,CACxBJ,WAAYA,IACZJ,QAASR,MElBbN,OAAOuB,iBAAiB,UAAxB,uCAAmC,WAAOC,GAAP,SAAAH,EAAA,yDACV,iBAAnBG,EAAGlB,KAAKH,OADqB,uBAE9BqB,EAAGC,OAAevB,YAAY,CAC7BwB,QAAS,MACTC,OAAQC,EACRC,GAAIL,EAAGlB,KAAKuB,IACXL,EAAGM,QANyB,6BAS5BX,EAAcK,EAAGlB,KAAKH,QATM,uBAU/BH,OAAOC,OAAOC,YAAY,CACxBwB,QAAS,MACTK,MAAO,CACLC,KAAM,MACNlC,QAAS,oBAEX+B,GAAIL,EAAGlB,KAAKuB,IACXL,EAAGM,QAjByB,0BAoBjCX,EAAcK,EAAGlB,KAAKH,QAAtB,MAAAgB,EAAa,YAAoBK,EAAGlB,KAAKD,QAA5B,QAAoCmB,EAAGM,UAAQG,MAAK,SAAClB,GAChEf,OAAOC,OAAOC,YAAY,CACxBwB,QAAS,MACTC,OAAQZ,EACRc,GAAIL,EAAGlB,KAAKuB,IACXL,EAAGM,WACLI,OAAM,SAACC,GACPX,EAAGC,OAAevB,YAAY,CAC7BwB,QAAS,MACTK,MAAO,CACLC,KAAM,MACNlC,QAASqC,EAAErC,SAEb+B,GAAIL,EAAGlB,KAAKuB,IACXL,EAAGM,WAlCyB,2CAAnC,uDAsCe,c","file":"static/js/main.e15792df.chunk.js","sourcesContent":["import { Connect, SendData } from \"../__GENERATED_TYPES__\";\nimport MetaMaskTransport from \"../transports/MetaMaskTransport\";\n\nexport interface IMethodMapping {\n  [methodName: string]: (...params: any) => Promise<any>;\n}\n\nlet transport: MetaMaskTransport | undefined;\nlet internalID = 0;\n\nconst connect: Connect = async () => {\n  transport = new MetaMaskTransport();\n  return transport.connect();\n};\n\nconst sendData: SendData = (data) => {\n  if (!transport) {\n    throw new Error(\"Not Connected\");\n  }\n  return transport.sendData({\n    internalID: internalID++,\n    request: data,\n  });\n};\n\nconst methodMapping: IMethodMapping = {\n  connect,\n  sendData,\n};\n\nexport default methodMapping;\n","import { Transport } from \"@open-rpc/client-js/build/transports/Transport\";\nimport { EventEmitter } from \"events\";\nimport { JSONRPCRequestData, IJSONRPCData } from \"@open-rpc/client-js/build/Request\";\n\ninterface RequestArguments {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object;\n}\n\ninterface EthereumProvider extends EventEmitter {\n  isMetaMask?: boolean;\n  request: (args: RequestArguments) => Promise<unknown>;\n}\n\ndeclare global {\n  interface Window {\n    ethereum?: EthereumProvider;\n  }\n}\n\ninterface ProviderMessage {\n  readonly type: string;\n  readonly data: unknown;\n}\n\nclass MetaMaskTransport extends Transport {\n\n  public async connect(): Promise<boolean> {\n    const hasEthereum = window.ethereum && window.ethereum.isMetaMask;\n    if (hasEthereum) {\n      window.ethereum?.on(\"message\", this.notificationHandler);\n      return Boolean(hasEthereum);\n    } else {\n      throw new Error(\"No MetaMask Connection\");\n    }\n  }\n\n  public async sendData(data: JSONRPCRequestData, timeout: number | undefined = 5000): Promise<any> {\n    const results = await window.ethereum?.request((data as IJSONRPCData).request);\n    return results;\n  }\n\n  public close(): void {\n    if (window.ethereum) {\n      window.ethereum.off(\"message\", this.notificationHandler);\n    }\n  }\n\n  private notificationHandler = (message: ProviderMessage) => {\n    const m: any = message;\n    window.parent.postMessage({\n      method: m.type,\n      params: m.data,\n    }, \"*\");\n  }\n}\n\nexport default MetaMaskTransport;\n","import openrpcDocument from \"./openrpc.json\";\nimport methodMapping from \"./methods/methodMapping\";\n\nwindow.addEventListener(\"message\", async (ev: MessageEvent) => {\n  if (ev.data.method === \"rpc.discover\") {\n    (ev.source as any).postMessage({\n      jsonrpc: \"2.0\",\n      result: openrpcDocument,\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  if (!methodMapping[ev.data.method]) {\n    window.parent.postMessage({\n      jsonrpc: \"2.0\",\n      error: {\n        code: 32009,\n        message: \"Method not found\",\n      },\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  methodMapping[ev.data.method](...ev.data.params, ev.origin).then((results: any) => {\n    window.parent.postMessage({\n      jsonrpc: \"2.0\",\n      result: results,\n      id: ev.data.id,\n    }, ev.origin);\n  }).catch((e: Error) => {\n    (ev.source as any).postMessage({\n      jsonrpc: \"2.0\",\n      error: {\n        code: 32329,\n        message: e.message,\n      },\n      id: ev.data.id,\n    }, ev.origin);\n  });\n});\n\nexport default {};\n"],"sourceRoot":""}